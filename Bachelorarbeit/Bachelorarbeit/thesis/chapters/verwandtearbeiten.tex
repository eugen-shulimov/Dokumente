\chapter{Verwandte Arbeiten}

\section{Parsen von C-Präprozessor-Annotationen für Variabilitätsanalysen}
DiffDetective ist ein Tool welches hilft Änderungen in Quellcode und Änderungen der Variabilität darstellbar und den Zusammenhang zwischen ihnen analysierbar zu machen~\cite{BTS+:ESECFSE22,BSM+:FSE24}. Um diesen Zweck zu erfüllen hat DiffDetective verschiedene Features. Mit dieser Arbeit haben wir die Anzahl der Features von DiffDetective erweitert und damit auch seine Einsatzmöglichkeiten erweitert. DiffDetective  überführt C-Präprozessor-Annotierten Code oder textbasierten Diff aus C-Präprozessor-Annotierten Code in einen Variation-Tree oder Variation-Diff~\cite{BSM+:FSE24}. Unparsen ist die Umkehrung von Parsen. Zusammen ermöglichen die Features in beide Richtungen umzuwandeln, von mit C-Präprozessor-Annotierten Code bzw. textbasierten Diff zu Variation-Tree bzw. Variation-Diff und umgekehrt von Variation-Tree bzw. Variation-Diff zu mit C-Präprozessor-Annotierten Code bzw. textbasierten Diff. Diese Funktionen müssen aber zur korrekten Arbeit auf einander abgestimmt werden, wie es unsere Arbeit zeigt. \\

Es gibt aber auch andre Parser für C-Präprozessor-Annotierten Code. Ein solcher Parser arbeitet statt mit dem C-Präprozessor-Annotierten Code mit den Token-Stream und generiert einen abstrakten Syntaxbaum~\cite{GG:PLDI12,KGR+:OOPSLA11}. Der Token-Stream mit welchen der Parser arbeitet, wird aus dem C-Präprozessor-Annotierten Code generiert, von einem Lexer~\cite{GG:PLDI12,KGR+:OOPSLA11}. Dieser Lexer löst Makros auf und fügt Files hinzu. Das führt mit sich das der Parser nicht nur mit C-Präprozessor-Annotationen arbeitet sondern mit dem ganzen C-Präprozessor-Annotierten Code~\cite{GG:PLDI12,KGR+:OOPSLA11}. Aus diesem Grund ist es nicht möglich unseren Unparser hier zu verwenden, da unser Parser nur C-Präprozessor-Annotationen als Kontrollstrukturen wahrnimmt und den C-Code nur als reinen Text wahrnimmt, was für diesen Parser nicht der Fall ist.\\

Es ist auch möglich den C-Präprozessor-Annotierten Code zu Formel zu parsen~\cite{STLS:GPCE10}. Dieses Vorgehen ist in Front-End und Back-End aufgeteilt~\cite{STLS:GPCE10}. In Front-End wird der C-Präprozessor-Annotierte Code analysiert und die C-Präprozessor-Annotationen extrahiert~\cite{STLS:GPCE10}. Dnach in Back-End werden auf dieser Basis die Formeln erstellt~\cite{STLS:GPCE10}. Das Ergebnis diesen Vorgangs sind Formeln, was uns eindeutig mitteilt das unserer Unparser hier nicht einsetzbar ist.\\

An diesen Möglichkeiten für das Parsen sehen wir, wie unterschiedlich die Ergebnisse des Parsens sein können, welches mit sich bringt das das Einsetzen unseren Unparsers nicht ohne weiteres für andere Parser möglich ist.

 
\section{Dekompilierung von C}
Dekompilierung ist die Umkehrung der Kompilierung so wie Unparsen die Umkehrung des Parsens ist. Unparser und die Dekompilierung generieren beide aus ihrer Eingabe einen Text bzw. Code. Die Dekompilierung ist in Front-End, Mid-End und Back-End aufgeteilt~\cite{10.1145/3650212.3652144,Cifuentes1993AMF,10.1145/3395363.3397370}. Das Front-End hat als Eingabe den Binärcode und verarbeitet diesen zu einer Zwischendarstellung des Programms~\cite{Cifuentes1993AMF,10.1145/3395363.3397370}. Im Mid-End wird aus der Zwischendarstellung des Programms die Information zum Kontrollfluss entnommen und eine Kontrollflussgraph erstellt. Zum Schluss im Back-End wird aus der Zwischendarstellung des Programms und dem Kontrollflussgraphen der  Code erstellt~\cite{Cifuentes1993AMF,10.1145/3395363.3397370}. Im Back-End genauso wie bei uns wird ein Graph und die Zwischendarstellung des Programms zu Code umgewandelt~\cite{Cifuentes1993AMF,10.1145/3395363.3397370}. Trotzdem, dass in beiden Fällen Graphen verwendet werden, können wir nicht den Ansatz der Dekompilierung verwenden, da bei der Dekompilierung mit dem Binärcode, den Zwischenergebnissen und konkretem C-Code gearbeitet wird~\cite{10.1145/3650212.3652144,Cifuentes1993AMF,10.1145/3395363.3397370}. In unseren Fall aber wird nur mit den C-Präprozessor-Annotationen interagiert und nicht mit dem C-Code oder dem Binärcode. In unserem Fall ist es sogar nicht der C-Code, da wir den C-Code nur als Text betrachten und mit den Code nicht explizit arbeiten. In dieser Hinsicht ist unser Unparser generell, solange die C-Präprozessor-Annotationen korrekt sind, kann der restlicher Inhalt beliebiger Text sein. Bei dem Decompiler ist es anders. Ein Dekompiler wird speziell für eine Programmiersprache entwickelt. Der C-Dekompiler wird für den C-Code entwickelt, der Java-Dekompilr für den Java-Code und so weiter. Der Dekompiler interagiert nicht mit den C-Präprozessor-Annotationen. Unseren Unparser und den Dekompiler kann man als parallele Prozesse betrachten, da diese an verschiedenen Stellen ansetzen.

\section{Variabilitätsanalysen}
Der Unparser ist Bestandteil einiger Variabilitätsanalysen. Eine mögliche Analyse sind die Mutation-Tests, welche eine der vielversprechendsten Techniken zur Bewertung der Effektivität von Testfällen sind. Die Mutation-Tests lassen sich auch zur Analyse der Testfälle, welche die Variabilität sichern sollten, verwenden~\cite{ABT+:VaMoS16,LS:SPLat14}. Allgemein bei Mutation-Tests wird der Code verändert. Diese Veränderungen sind nicht willkürlich sondern haben gewisse Eigenschaften, welche vor den Test festgelegt werden~\cite{ABT+:VaMoS16,LS:SPLat14}. Nach diesen Veränderungen erhält man neu leicht modifizierte Kopien des ausgangs Codes. Auf diese Kopien werden dann die Testfälle für den ausgangs Code verwendet und geschaut ob die modifizierte Version des Codes einen Fehler erzeugt oder nicht~\cite{ABT+:VaMoS16,LS:SPLat14}. Dadurch lässt sich Feststellen wie gut die Testfälle ausgewählt wurden. Dieses Vorgehen lässt sich auch in Kontext der Variabilität verwenden. Dabei werden die Veränderung nur an den Stellen erzeugt, welche für die Variabilität zuständig sind~\cite{ABT+:VaMoS16,LS:SPLat14}. Im Falle das für die Erzeugung der Variabilität der C-Präprozessor verwendet wird, sind das die C-Präprozessor-Annotationen. Im Bezug auf unsere Arbeit ist nur dieser Fall für uns von Bedeutung. Dabei wird am Anfang der Code zu Variation-Tree geparst und es gibt bessere differenzierung zwischen ausführbaren Code und den Bestandteilen der Variabilitätserzeugung. Danach werden die Veränderungen angewandt. An dieser Stelle wird unser Unparser angewendet und überführt das Variation-Tree in ausführbaren Code auf den die Tests angewandt werden können und die Mutation-Tests werden durchgeführt. Das macht unseren Unparser zu Bestandteil von Variabilitätsanalysen.









