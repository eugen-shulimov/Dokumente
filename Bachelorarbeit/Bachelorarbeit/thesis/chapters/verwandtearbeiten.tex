\chapter{Verwandte Arbeiten}

\section{Parsen von C-Präprozessor-Annotationen für Variabilitätsanalysen}
DiffDetective ist ein Tool, welches hilft Änderungen in Quellcode und Änderungen der Variabilität darstellbar und den Zusammenhang zwischen ihnen analysierbar zu machen~\cite{BTS+:ESECFSE22,BSM+:FSE24}. Um diesen Zweck zu erfüllen hat DiffDetective verschiedene Features. Mit dieser Arbeit haben wir die Anzahl der Features von DiffDetective erweitert und damit auch seine Einsatzmöglichkeiten erweitert. DiffDetective  überführt C-Präprozessor-Annotierten Code oder textbasierten Diff aus C-Präprozessor-Annotierten Code in einen Variation-Tree oder Variation-Diff~\cite{BSM+:FSE24}. Unparsen ist die Umkehrung von Parsen. Zusammen ermöglichen die Features in beide Richtungen umzuwandeln, von mit C-Präprozessor-Annotierten Code bzw. textbasierten Diff zu Variation-Tree bzw. Variation-Diff und umgekehrt von Variation-Tree bzw. Variation-Diff zu mit C-Präprozessor-Annotierten Code bzw. textbasierten Diff. Diese Funktionen müssen aber zur korrekten Arbeit aufeinander abgestimmt werden, wie es unsere Arbeit zeigt. \\

Es gibt aber auch andre Parser für C-Präprozessor-Annotierten Code. Ein solcher Parser arbeitet statt mit dem C-Präprozessor-Annotierten Code mit dem Token-Stream und generiert einen abstrakten Syntaxbaum~\cite{GG:PLDI12,KGR+:OOPSLA11}. Der Token-Stream mit welchen der Parser arbeitet, wird aus dem C-Präprozessor-Annotierten Code generiert, von einem Lexer~\cite{GG:PLDI12,KGR+:OOPSLA11}. Dieser Lexer löst Makros auf und fügt Files hinzu. Das führt mit sich das der Parser nicht nur mit C-Präprozessor-Annotationen arbeitet, sondern mit dem ganzen C-Präprozessor-Annotierten Code~\cite{GG:PLDI12,KGR+:OOPSLA11}. Aus diesem Grund ist es nicht möglich unseren Unparser hier zu verwenden, da unser Parser nur C-Präprozessor-Annotationen als Kontrollstrukturen wahrnimmt und den C-Code nur als reinen Text wahrnimmt, was für diesen Parser nicht der Fall ist.\\

Es ist auch möglich den C-Präprozessor-Annotierten Code zu Formel zu parsen~\cite{STLS:GPCE10}. Dieses Vorgehen ist in Front-End und Back-End aufgeteilt~\cite{STLS:GPCE10}. In Front-End wird der C-Präprozessor-Annotierte Code analysiert und die C-Präprozessor-Annotationen extrahiert~\cite{STLS:GPCE10}. Dnach in Back-End werden auf dieser Basis die Formeln erstellt~\cite{STLS:GPCE10}. Das Ergebnis dieses Vorgangs sind Formeln, was uns eindeutig mitteilt das, unserer Unparser hier nicht einsetzbar ist.\\

An diesen Möglichkeiten für das Parsen sehen wir, wie unterschiedlich die Ergebnisse des Parsens sein können, welches mit sich bringt, dass das Einsetzen unseren Unparsers nicht ohne weiteres für andere Parser möglich ist.

 
\section{Dekompilierung von C}
Dekompilierung ist die Umkehrung der Kompilierung so wie Unparsen die Umkehrung des Parsens ist. Unparser und die Dekompilierung generieren beide aus ihrer Eingabe einen Text bzw. Code. Die Dekompilierung ist in Front-End, Mid-End und Back-End aufgeteilt~\cite{10.1145/3650212.3652144,Cifuentes1993AMF,10.1145/3395363.3397370}. Das Front-End hat als Eingabe den Binärcode und verarbeitet diesen zu einer Zwischendarstellung des Programms~\cite{Cifuentes1993AMF,10.1145/3395363.3397370}. Im Mid-End wird aus der Zwischendarstellung des Programms die Information zum Kontrollfluss entnommen und eine Kontrollflussgraph erstellt. Zum Schluss im Back-End wird aus der Zwischendarstellung des Programms und dem Kontrollflussgraphen der  Code erstellt~\cite{Cifuentes1993AMF,10.1145/3395363.3397370}. Im Back-End genauso wie bei uns wird ein Graph und die Zwischendarstellung des Programms zu Code umgewandelt~\cite{Cifuentes1993AMF,10.1145/3395363.3397370}. Trotzdem, dass in beiden Fällen Graphen verwendet werden, können wir nicht den Ansatz der Dekompilierung verwenden, da bei der Dekompilierung mit dem Binärcode, den Zwischenergebnissen und konkretem C-Code gearbeitet wird~\cite{10.1145/3650212.3652144,Cifuentes1993AMF,10.1145/3395363.3397370}. In unseren Fall aber wird nur mit den C-Präprozessor-Annotationen interagiert und nicht mit dem C-Code oder dem Binärcode. In unserem Fall ist es sogar nicht der C-Code, da wir den C-Code nur als Text betrachten und mit dem Code nicht explizit arbeiten. In dieser Hinsicht ist unser Unparser generell, solange die C-Präprozessor-Annotationen korrekt sind, kann der restliche Inhalt beliebiger Text sein. Bei dem Decompiler ist es anders. Ein Dekompiler wird speziell für eine Programmiersprache entwickelt. Der C-Dekompiler wird für den C-Code entwickelt, der Java-Dekompilr für den Java-Code und so weiter. Der Dekompiler interagiert nicht mit den C-Präprozessor-Annotationen. Unseren Unparser und den Dekompiler kann man als parallele Prozesse betrachten, da diese an verschiedenen Stellen ansetzen.

\section{Variabilitätsanalysen}
Bei Analysen oder Verarbeitungsschritten kann es vorkommen, dass der Code auf abstrakter Ebene verändert wird. Danach muss man Unparsen um einen Code wieder zubekommen. Ein Beispiel für so etwas sind die Mutation-Tests~\cite{ABT+:VaMoS16,LS:SPLat14}, welche eine der vielversprechendsten Techniken zur Bewertung der Effektivität von Testfällen sind. Die Mutation-Tests lassen sich auch zur Analyse der Testfälle, welche die Variabilität sichern sollten, verwenden~\cite{ABT+:VaMoS16,LS:SPLat14}. Allgemein bei Mutation-Tests wird der Code verändert. Diese Veränderungen sind nicht willkürlich, sondern haben gewisse Eigenschafte~\cite{ABT+:VaMoS16,LS:SPLat14}. Nach diesen Veränderungen erhält man neu leicht modifizierte Kopien des Ausgangscodes. Auf diese Kopien werden dann die Testfälle für den Ausgangscode verwendet und geschaut, ob die modifizierte Version des Codes einen Fehler erzeugt oder nicht~\cite{ABT+:VaMoS16,LS:SPLat14}. Dadurch lässt sich Feststellen wie gut die Testfälle ausgewählt wurden. Dieses Vorgehen lässt sich auch im Kontext der Variabilität verwenden. Dabei werden die Veränderung nur an den Stellen erzeugt, welche für die Variabilität zuständig sind~\cite{ABT+:VaMoS16,LS:SPLat14}. Im Falle das für die Erzeugung der Variabilität der C-Präprozessor verwendet wird, sind das die C-Präprozessor-Annotationen. In Bezug auf unsere Arbeit ist nur dieser Fall für uns von Bedeutung. Dabei wird am Anfang der Code zu einem Variation-Tree geparst. Danach werden die Veränderungen angewandt. An dieser Stelle wird unser Unparser angewendet und überführt das Variation-Tree in ausführbaren Code, auf den die Tests angewandt werden können und die Mutation-Tests werden durchgeführt. \\

Ein weiteres Beispiel ist die Analyse, welche Codeblöcke finden soll, die in keiner Variante auftauche~\cite{TSS+:FOSD09}. Bei dieser Analyse werden zwei Datenbanken erstellt. Die erste Datenbank enthält das Variabilität-Model, welches zeigt in welchen Kombinationen die Features ausgewählt werden dürfen~\cite{TSS+:FOSD09}. Die zweite Datenbank enthält den Variabilität, welche tatsächlich in Code umgesetzt wurde~\cite{TSS+:FOSD09}. Damit dieser erhalten wird, muss man den Code Parsen. Danach ist es möglich für beide Datenbanken jeweils die Feature-Abhängigkeiten in ein binäres Entscheidungsdiagramm umzuwandeln. Anhand dessen man die Erfüllbarkeit überprüfen kann~\cite{TSS+:FOSD09}. Es liegt nah danach die niemals erfüllbaren Codeblöcke zu entfernen und die restlichen unzuparsen, um einen neuen Code zu bekommen.\\

Bei Variabilitätsanalysen ist es auch möglich zu prüfen, ob alle Varianten syntaktisch korrekt sind. Dabei muss zuerst der Präprozessor-Annotierter Code zu einem abstrakten Syntaxbaum geparst werden~\cite{KAK:ICSE08}. Danach wird dieser abstrakter Syntaxbaum von dem Tool CIDE eingelesen. CIDE ist ein Tool, welcher es erlaubt verschiedene Features verschiedenfarbig einzufärben~\cite{KAK:ICSE08}. Im Zusammenhang mit der Analyse der syntaktischen Korrektheit aller Varianten ist von Bedeutung das CIDE nur das Einfärben der Codefragmente, welche optional für diejenige Programmiersprache sind~\cite{KAK:ICSE08}. Also so das bei Entfernen der eingefärbten Codefragmente die Syntax trotzdem gültig bleibt. \\

Noch eine weitere Variabilitätsanalyse ist die Prüfung der Typkorrektheit für alle Varianten. Vor der Analyse muss der Parser den Präprozessor-Annotierten Code in einen bestimmten Kalkül überführen~\cite{KA:ASE08}. Danach wird anhand der Vorschriften des Kalküls geprüft werden um zu finden, wo der Typ nicht eingehalten wurde und dieses beheben~\cite{KA:ASE08}. Schließlich kann man den Kalkül zu einem Präprozessor-Annotierten Code unparsen und den weiter bearbeiten.






